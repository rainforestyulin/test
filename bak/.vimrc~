"===============================================================================
"         FILE:  vimrc
"  DESCRIPTION:  suggestion for a personal configuration file vimrc
"       AUTHOR:  Dr.-Ing. Fritz Mehner <mehner@fh-swf.de>
"      CREATED:  04.04.2009
"     REVISION:  $Id: customization.vimrc,v 1.6 2009/10/03 12:24:30 mehner Exp $
"       AUTHOR:  Yulin <202122220435@uestc.edu.cn>
"     MODIFIED:  04.07.2022
"===============================================================================

"===============================================================================
" PATH
"===============================================================================
" The directory where 'init.vim' resides.
function! GetVimHome()
    if has('win32')
        let path=expand('~/vimfiles')
    elseif has('unix')
        let path=expand('~/.vim')
    endif
    return path
endfunction
"
let vimrc_path=GetVimHome()

"-------------------------------------------------------------------------------
" Backup directory
"-------------------------------------------------------------------------------
" Set backup directory.
let backup_path=vimrc_path.'/bak'
if !isdirectory(backup_path)
    call mkdir(backup_path, 'p')
endif
let &backupdir=backup_path
"
"-------------------------------------------------------------------------------
" Swap directory
"-------------------------------------------------------------------------------
" Set swap directory.
let swap_path=vimrc_path.'/swp'
if !isdirectory(swap_path)
    call mkdir(swap_path, 'p')
endif
let &directory=swap_path
" Do not swap file, since it can be troublesome.
set noswapfile
"
"-------------------------------------------------------------------------------
" Undo directory
"-------------------------------------------------------------------------------
" Enable persistent undo for unloaded buffer.
set undofile
if !has('nvim')
    let undo_path=vimrc_path.'/undo'
else " Neovim uses an incompatible undo format.
    let undo_path=vimrc_path.'/nvim/undo'
endif
if !isdirectory(undo_path)
    call mkdir(undo_path, 'p')
endif
let &undodir=undo_path
"
"-------------------------------------------------------------------------------
" Bundle directory
"-------------------------------------------------------------------------------
" Set bundle directory.
let bundle_path=vimrc_path.'/bundle'
if !isdirectory(bundle_path)
    call mkdir(bundle_path, 'p')
endif
let &runtimepath.=','.vimrc_path.'/yl'
let repos_path=bundle_path.'/repos'

"-------------------------------------------------------------------------------
" PYTHON
"-------------------------------------------------------------------------------
if has('win32')
    let g:python_host_prog = 'C:/Python-2.7/python.exe'
    let g:python3_host_prog = 'C:/Python-3.10/python.exe'
elseif has('unix')
    let g:python_host_prog = '/usr/bin/python'
    let g:python3_host_prog = '/usr/bin/python3'
endif

"===============================================================================
" GENERAL SETTINGS
"===============================================================================
"
"-------------------------------------------------------------------------------
" Language
"-------------------------------------------------------------------------------
" Set default encoding.
set encoding=utf-8
"
" Set language for menus.
set langmenu=en_US.utf-8
"
" Set message encoding.
language message en_US.utf-8
"
"-------------------------------------------------------------------------------
" Color scheme
"-------------------------------------------------------------------------------
" Enables 24-bit RGB color in the TUI.
if has('nvim')
    set termguicolors
endif
"
" Set gui color depth to 256.
set t_Co=256
"
" Set color scheme.
colorscheme calmar256x-dark
"
"-------------------------------------------------------------------------------
" Screen & window
"-------------------------------------------------------------------------------
" Show guideline at 81-th column.
set colorcolumn=81
"
" Reserve 4 columns for showing line number, plus 1 column for visibility.
set winwidth=88
if has('nvim')
    autocmd WinEnter * :set winwidth=88
endif

"-------------------------------------------------------------------------------
" GUI Font
"-------------------------------------------------------------------------------
if has('win32')
    set guifont=Consolas:h12
    set guifontwide=Microsoft\ YaHei\ UI:h12
elseif has('unix')
endif

"-------------------------------------------------------------------------------
" Various settings
"-------------------------------------------------------------------------------
syntax enable                   " enable syntax highlighting
filetype plugin indent on       " enable language-dependent indenting
set autoindent                  " copy indent from current line
set autoread                    " read opened files when changed outside Vim.
                                " In Neovim, use :e<CR> to read manually.
set autowrite                   " write a modified buffer on each :next ,...
set backspace=indent,eol,start  " backspacing over everything in insert mode
set backup                      " keep a backup file
set browsedir=current           " which directory to use for the file browser
set cmdheight=2                 " prevent status line to be overwritten by mode message
set complete+=k                 " scan the files given with the 'dictionary' option
set concealcursor=n             " conceal text only in normal mode
set conceallevel=2              " conceal text completely
set cscopeverbose
set cursorline                  " hightlight current curor line and line number
set expandtab                   " use spaces for indentation, instead of tabs
set foldmethod=marker           " fold by using markers
set formatoptions+=nBj          " n: recognize numbered lists
                                " B: don't insert a space between multi-byte characters when joining lines
                                " j: remove a comment leader when joining lines
set guioptions=egrL             " gVim options.
                                " e: use GUI tabs.
                                " -m: no menu bar.
                                " g: grey inactive menu items.
                                " -t: no tearoff menu items (like Motif).
                                " -T: no toolbar.
                                " r: show right-hand scrollbar.
                                " L: show left-hand scrollbar when vertically split.
set hidden                      " keep changed buffer without saving it
set history=10000               " keep 10000 lines of command line history
set hlsearch                    " highlight the last used search pattern
set incsearch                   " do incremental searching
set laststatus=2                " always show the status line
set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
                                " strings to use in 'list' mode
set mouse=a                     " enable the use of the mouse
set nocompatible                " always use new features
set nowrap                      " do not wrap lines
set number                      " show line number
set popt=left:8pc,right:3pc     " print options
set relativenumber              " show the line number relative to the cursor
set ruler                       " show the cursor position all the time
set scrolloff=1                 " show at least 1 line below and after cursor
set sessionoptions-=options     " do not save options and mappings in session script
set shortmess+=c                " do not give completion popup menu messages
set shiftwidth=4                " number of spaces to use for each step of indent
set signcolumn=yes              " always draw signcolumn to show quickfix and syntax error signs
set showcmd                     " display incomplete commands
set showmatch                   " show the matching pair for parenthesis, brackets and braces
set sidescrolloff=5             " show at least 5 columns to the left and right of the cursor
set smartindent                 " smart autoindenting when starting a new line
set smarttab                    " use 'shiftwidth' at the beginning of a line
set tabpagemax=50               " set the maximum number of tabpages
set tabstop=4                   " number of spaces that a <Tab> counts for
set updatetime=100              " set idle time before CursorHold event
set viewoptions-=options        " do not save options and mappings in window session script
set visualbell                  " visual bell instead of beeping
set wildignore=*.bak,*.o,*.e,*~ " wildmenu: ignore these extensions
set wildmenu                    " command-line completion in an enhanced mode
set clipboard=unnamedplus
"===============================================================================
" BUFFERS, WINDOWS
"===============================================================================

"-------------------------------------------------------------------------------
" Always display incomplete commands.
"-------------------------------------------------------------------------------
autocmd BufEnter * :set showcmd

"-------------------------------------------------------------------------------
" The current directory is the directory of the file in the current window.
"-------------------------------------------------------------------------------
" Commented: Exclude coc.nvim buffers.
"autocmd BufEnter * :if bufname() !~ '^list:///' | :lchdir %:p:h | :endif

"-------------------------------------------------------------------------------
" Indent JSON files by 2 spaces.
"-------------------------------------------------------------------------------
autocmd BufEnter *.json,*.jsonc :setlocal shiftwidth=2 | :setlocal tabstop=2

"-------------------------------------------------------------------------------
" Leave the editor with Ctrl-q (KDE): Write all changed buffers and exit Vim
"-------------------------------------------------------------------------------
nnoremap  <C-q>    :wqall<CR>

"-------------------------------------------------------------------------------
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
"-------------------------------------------------------------------------------
autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif

"-------------------------------------------------------------------------------
" Window navigation.
"-------------------------------------------------------------------------------
" Shortcuts for navigating among windows.
noremap <C-j>  <C-w>j
noremap <C-k>  <C-w>k
noremap <C-h>  <C-w>h
noremap <C-l>  <C-w>l

"-------------------------------------------------------------------------------
" Buffer navigation.
"-------------------------------------------------------------------------------
" Shortcuts for navigating buffers.
noremap <C-TAB>   :bn<CR>
noremap <C-S-TAB> :bp<CR>

"-------------------------------------------------------------------------------
" Duplicate tab.
"-------------------------------------------------------------------------------
command! -bar DuplicateTabpane
      \ let s:sessionoptions = &sessionoptions |
      \ try |
      \   let s:this_session = v:this_session |
      \   let &sessionoptions = 'blank,buffers,curdir,folds,globals,help,options,winsize' |
      \   let s:file = tempname() |
      \   execute 'mksession ' . s:file |
      \   tabnew |
      \   let s:tabnr = tabpagenr() |
      \   execute '-tabclose ' |
      \   execute 'source ' . s:file |
      \ finally |
      \   silent call delete(s:file) |
      \   let &sessionoptions = s:sessionoptions |
      \   let v:this_session = s:this_session |
      \   unlet! s:file s:sessionoptions s:this_session s:tabnr |
      \ endtry
"===============================================================================
" EDITTING
"===============================================================================

"-------------------------------------------------------------------------------
" Copy string to clipboard
"-------------------------------------------------------------------------------
noremap <Leader><Leader>y  "*yi"
noremap <Leader><Leader>p  "*p
noremap <Leader><Leader>P  "*P

"-------------------------------------------------------------------------------
" comma always followed by a space
"-------------------------------------------------------------------------------
inoremap  ,  ,<Space>

"-------------------------------------------------------------------------------
" Remove entered word by Ctrl-Backspace in Insert mode.
"-------------------------------------------------------------------------------
" Remove a word backward, blanks between cursor and the word are also removed.
inoremap <C-BS>   <Esc>dbs
" Remove 4 characters backward.
inoremap <C-SBS> <BS><BS><BS><BS>

"-------------------------------------------------------------------------------
" Add spaces rightward.
"-------------------------------------------------------------------------------
inoremap <C-L> <SPACE><SPACE><SPACE><SPACE>

"-------------------------------------------------------------------------------
" Indentation styles.
" :h cino->
"-------------------------------------------------------------------------------
" Allman (ANSI) Style
" g0   : C++ public, protected, private are indented as class brace.
" N-1s : C++ namespace scope has no additional indent.
" E-1s : C++ extern scope has no additional indent.
set cino=>1s,e0,n0,f0,{0,}0,^0,L-1,:0,=1s,l1,b0,g0,h1s,N-1s,E-s,p1s,t0,i1s,+1s,c3,C0,/0,(0,u0,U0,w0,W1s,m1,M0,j1,J1
"
" nnoremap <Leader><Leader>sa :set cino=>1s,e0,n0,f0,{0,}0,^0,L-1,:0,=1s,l1,b0,g0,h1s,N-1s,E-1s,p1s,t0,i1s,+1s,c3,C0,/0,(0,u0,U0,w0,W1s,m1,M0,j1,J1<CR>:set tabstop=4<CR>:set shiftwidth=4<CR>
"
" Whitesmith Style
" set cino=>1s,e0,n0,f1s,{1s,}0,^0,L-1,:0,=1s,l1,b0,g0,h1s,N-1s,p1s,t0,i1s,+1s,c3,C0,/0,(0,u0,U0,w0,W1s,m1,M0,j1,J1
"
" nnoremap <Leader><Leader>sw :set cino=>1s,e0,n0,f0,{0,}0,^0,L-1,:0,=1s,l1,b0,g0,h1s,N-1s,p1s,t0,i1s,+1s,c3,C0,/0,(0,u0,U0,w0,W1s,m1,M0,j1,J1<CR>:set tabstop=4<CR>:set shiftwidth=4<CR>
"
" GNU Style
" Manual: remove indents for braces of non-statement constructs
"         (namespace, struct, enum, class, function, ...)
" set cino=>2s,e-1s,n-1s,f0,{1s,}0,^-1s,L-1,:1s,=1s,l1,b0,g0,h1s,N-1s,p2s,t0,i1s,+1s,c3,C0,/0,(0,u0,U0,w0,W1s,m1,M0,j1,J1
"
" nnoremap <Leader><Leader>sg :set cino=>2s,e-1s,n-1s,f0,{1s,}0,^-1s,L-1,:1s,=1s,l1,b0,g0,h1s,N-1s,p2s,t0,i1s,+1s,c3,C0,/0,(0,u0,U0,w0,W1s,m1,M0,j1,J1<CR>:set tabstop=2<CR>:set shiftwidth=2<CR>

"-------------------------------------------------------------------------------
" doxygen highlighting
"-------------------------------------------------------------------------------
" Do not use the official doxygen syntax highlighting scheme.
let g:load_doxygen_syntax = 0
"
" Font for codeword.
" let g:doxygen_codeword_font = 'Cascadia Code'
"
" Use the new doxygen syntax highlighting scheme.
" Syntax highlighting for pure Doxygen files.
autocmd BufNewFile,BufRead *.doxygen setfiletype doxy
"
autocmd Syntax c,cpp,make,dosbatch
  \ if exists('b:current_syntax')
  \   | runtime! syntax/doxy.vim
  \ | endif

"-------------------------------------------------------------------------------
" jsonc highlighting
"-------------------------------------------------------------------------------
" JSON with C++ style comment.
autocmd FileType json syntax match Comment +/\/\.\+$+

"===============================================================================
" PLUGINS (managed by 'junegunn/vim-plug')
"===============================================================================
" 'plug.vim' shall be placed in '~/.vim/autoload/'.
" However, to automatically update 'plug.vim', one can put a symbolic link of
" 'plug.vim' in '~/.vim/autoload/'.
" mkdir ~/.vim/autoload
" ln -s ~/.vim/bundle/repos/vim-plug/plug.vim  ~/.vim/autoload
let g:plug_threads = 3
call plug#begin(repos_path)
    " =========================
    " Plugin manager
    " =========================
    " A minimalist Vim plugin manager.
    " Comment: Simple, fast, yet powerful.
    "          Much faster than 'Shougo/dein.vim'.
    "          'Shougo/dein.vim' merges plugins into a single directory,
    "          thus the `rtp` is short and clean.
	"          Use `PlugUpgrade` to upgrade `vim-plug` itself.
    " Plug 'junegunn/vim-plug'
    "
    " =========================
    " Neovim on Vim
    " =========================
    if !has('nvim')
        " This is an experimental project, trying to build a compatibility layer for neovim rpc client working on vim8.
        Plug 'roxma/vim-hug-neovim-rpc'
        " Yet Another Remote Plugin Framework for Neovim.
        Plug 'roxma/nvim-yarp'
    endif
    "
    " =========================
    " LSP client
    " =========================
    " Intellisense engine for vim8 & neovim, full language server protocol support as VSCode.
    " Comment: Fully functional LSP client.
    "          Cache for each project.
    Plug 'neoclide/coc.nvim', { 'branch': 'release' }
    " Plug 'neoclide/coc.nvim', { 'do': 'yarn install --frozen-lockfile' }
    " Extended Vim syntax highlighting for C and C++ (C++11/14/17/20).
    " Comment: Not ideal.
    "          e.g., strings are not recognized correctly in macro/function
    "          calls.
    "          Many highlightings has bad contrast/brightness.
    Plug 'bfrg/vim-cpp-modern'
    " Additional Vim syntax highlighting for C++ (including C++11/14/17).
    " Plug 'octol/vim-cpp-enhanced-highlight'
    " Print documents in echo area.
    " Comment: Replaced by coc.nvm.
    " Plug 'Shougo/echodoc'
    "
    " =========================
    " Snippet tools
    " =========================
    " The ultimate snippet solution for Vim. Send pull requests to SirVer/ultisnips!
    " Comment: Powerful, with interoperability with python and vim script.
    Plug 'SirVer/ultisnips'
    "
    " =========================
    " Highlighting
    " =========================
    " Highlight several words in different colors simultaneously.
    " Comment: The highest version just works.
    "Plug 'inkarkat/vim-mark', { 'commit': 'd9431b7cf5ddf1828035b45b7becd8a985d4311d' }
    " Comment: The newer versions depend upon a giganic library
    "          'inkarkat/vim-ingo-library' with a tiny dependency.
    " call Plug 'inkarkat/vim-mark', { 'branch': 'stable' }
    " Comment: Thanks for the standalone version.
    Plug 'ayuanx/vim-mark-standalone', { 'tag': '3.0.0_standalone' }
    "
    " =========================
    " Indent guides
    " =========================
    " A Vim plugin for visually displaying indent levels in code.
    " Comment: The vertical lines are thick, but it works without many problems.
    Plug 'nathanaelkane/vim-indent-guides'
    " A vim plugin to display the indention levels with thin vertical lines.
    " Comment: Display thin vertical lines embedded in the background, very
    "          calm and noise-free.
    "          However, it interferes with conceal settings, and pollutes
    "          concealed syntax items (concealed delimiters are no longer
    "          concealed and shown as indent guides).
    " Plug 'Yggdroot/indentLine'
    " Display a guide for the current line's indent level.
    " Comment: Dynamic indent guides, fancy, but the cursor have to be moved to
    "          the scope in order to display indent guides for that scope.
    "          Inconvenient for code reading.
    " Plug 'tweekmonster/local-indent.vim'
    if has('nvim')
        " The fastest Neovim colorizer.
        " Comment: Simple and fast, but only useful when working with colors
        "          alone, since it pollutes the highlightings of syntax items.
        Plug 'norcalli/nvim-colorizer.lua'
    endif
    "
    " =========================
    " Colorschemes
    " =========================
    " Top 100(ish) Themes, GUI Menu.
    " Plug 'vim-scripts/Colour-Sampler-Pack'
    " Colorsheme Scroller, Chooser, and Browser.
    " Plug 'vim-scripts/ScrollColors'
    " All 256 xterm colors with their RGB equivalents, right in Vim!
    Plug 'vim-scripts/xterm-color-table.vim'
    "
    " =========================
    " General tools
    " =========================
    " Highlights trailing whitespace in red and provides :FixWhitespace to fix it.
    Plug 'bronson/vim-trailing-whitespace'
    " Vim plug for switching between companion source files (e.g. '.h' and '.cpp').
    Plug 'derekwyatt/vim-fswitch'
    " A Vim alignment plugin.
    Plug 'junegunn/vim-easy-align'
    " Vim syntax highlighting plugin for JSON with C-style line (//) and block (/* */) comments.
    Plug 'kevinoid/vim-jsonc'
    " Speed up Vim by updating folds only when just.
    Plug 'Konfekt/FastFold'
    " A plugin which makes swapping of text in Vim easier.
    " The original plugin has naming conflict with 'machakann/vim-swap'.
    " As the plugin is no longer maintained by the original author, it is forked
    " and renamed.
    " Plug 'kurkale6ka/vim-swap'
    " Plug 'yulin/vim-swap-operands'
    " Vim motions on speed!
    Plug 'Lokaltog/vim-easymotion'
    " A Vim text editor plugin to swap delimited items.
    Plug 'machakann/vim-swap'
    " Argumentative aids with manipulating and moving between function arguments.
    " Comment: Argument swapping scrolls and blinks the screen.
    " Plug 'PeterRincker/vim-argumentative'
    " Provides auto-balancing and some expansions for parens, quotes, etc.
    Plug 'Raimondi/delimitMate'
    " Mark quickfix & location list items with signs.
    Plug 'tomtom/quickfixsigns_vim'
    " An extensible & universal comment vim-plugin that also handles embedded filetypes.
    Plug 'tomtom/tcomment_vim'
    " Enable repeating supported plugin maps with '.'.
    Plug 'tpope/vim-repeat'
    " Defaults everyone can agree on.
    Plug 'tpope/vim-sensible'
    " Quoting/parenthesizing made simple.
    Plug 'tpope/vim-surround'
    " Pairs of handy bracket mappings.
    Plug 'tpope/vim-unimpaired'
    " Extended % matching for HTML, LaTeX, and many other languages.
    Plug 'vim-scripts/matchit.zip'
    "
    " =========================
    " IDE like
    " =========================
    " Active fork of kien/ctrlp.vimâ€”Fuzzy file, buffer, mru, tag, etc finder.
    " Comment: Unhandy.
    "          Have to use <C-j>, <C-k> to move around, an anti-VIM experience.
    " Plug 'ctrlpvim/ctrlp.vim'
    " The fancy start screen for Vim.
    " Comment: Session and MRU management is quite handy.
    "          The header quotes is a sweet addition.
    Plug 'mhinz/vim-startify'
    " A tree explorer plugin for vim.
    Plug 'scrooloose/nerdtree'
    " Buffer Explorer / Browser.
    Plug 'vim-scripts/bufexplorer.zip'
    " Plugin to manage Most Recently Used (MRU) files.
    Plug 'vim-scripts/mru.vim'
    "
    " =========================
    " Tag tools
    " =========================
    " A Vim plugin that manages your tag files.
    Plug 'ludovicchabant/vim-gutentags'
    " Vim plugin that displays tags in a window, ordered by scope.
    Plug 'majutsushi/tagbar'
    "
    " =========================
    " Git tools
    " =========================
    " A Git wrapper so awesome, it should be illegal.
    Plug 'tpope/vim-fugitive'
    "
    " =========================
    " C/C++ tools
    " =========================
    " C/C++ IDE -- Write and run programs. Insert statements, idioms, comments etc.
    " Comment: the complex mappings can be troublesome.
    "Plug 'vim-scripts/c.vim'
    " Simplify Doxygen documentation in C, C++, Python.
    Plug 'vim-scripts/DoxygenToolkit.vim'
call plug#end()

"===============================================================================
" VARIOUS PLUGIN CONFIGURATIONS
"===============================================================================

"=======================================
" LSP client
"=======================================
"---------------------------------------
" neoclide/coc.nvim
"---------------------------------------
" Configurations.
"
let g:coc_config_home = vimrc_path
"
" Check whether coc.vim installed.
if isdirectory(repos_path.'/coc.nvim')
    " Use <TAB> for trigger completion and navigate to the next complete item.
    function! CheckBackspace() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~ '\s'
    endfunction
    "
    " Use <C-SPACE> to trigger completion.
    inoremap <silent><expr> <C-SPACE> coc#refresh()
    "
    " Use <CR> to confirm completion without expanding a snippet
    " (<C-y> is always available to expand a snippet).
    inoremap <silent><expr> <CR> pumvisible() ? "\<Down>\<C-P>" : "\<C-G>u\<CR>"
    "
    " Snippet navigation keys.
    let g:coc_snippet_next = '<TAB>'
    let g:coc_snippet_prev = '<S-TAB>'
    "
    " Use '[c' and ']c' to navigate diagnostics.
    nmap <silent> [c <Plug>(coc-diagnostic-prev)
    nmap <silent> ]c <Plug>(coc-diagnostic-next)
    "
    " Various actions.
    nmap <silent> <Leader>gd <Plug>(coc-definition)
    nmap <silent> <Leader>gt <Plug>(coc-type-definition)
    nmap <silent> <Leader>gi <Plug>(coc-implementation)
    nmap <silent> <Leader>gr <Plug>(coc-references)
    nmap <silent> <Leader>fc <Plug>(coc-fix-current)
    nmap <silent> <Leader>fh <Plug>(coc-float-hide)
    nmap <silent> <Leader>fj <Plug>(coc-float-jump)
    nmap <silent> <Leader>rf <Plug>(coc-refactor)
    nmap <silent> <Leader>rn <Plug>(coc-rename)
    "
    function! s:show_documentation()
        if (index(['vim', 'help'], &filetype) >= 0)
            execute 'h '.expand('<cword>')
        else
            call CocActionAsync('doHover')
        endif
    endfunction
    nmap <silent> K :call <SID>show_documentation()<CR>
    "
    " Show signature for symbol when jumped to next/prev placeholder in a snippet.
    autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
    "
    " Show signature for symbol under cursor in insert mode.
    autocmd CursorHoldI * silent call CocActionAsync('showSignatureHelp')
    "
    " Highlight symbol under cursor.
    autocmd CursorHold * silent call CocActionAsync('highlight')
    hi def link CocHighlightText Pmenu
    "
    " Show in status line.
    function! CocStatusDiagnostic() abort
        let info = get(b:, 'coc_diagnostic_info', {})
        if empty(info) | return '' | endif
        let msgs = []
        if get(info, 'error',   0) | call add(msgs, 'E' . info['error'])   | endif
        if get(info, 'warning', 0) | call add(msgs, 'W' . info['warning']) | endif
        call add(msgs, get(g:, 'coc_status', ''))
        " call add(msgs, get(b:, 'coc_current_function', ''))
        return join(msgs, ' ')
    endfunction
    "
    " set statusline=%n\ %<%f\ %h%m%r%=%{CocStatusDiagnostic()}\ %{gutentags#statusline('[',']')}\ %-14.(%l,%c%V%)\ %P
    set statusline=%n\ %<%f\ %h%m%r%=%{CocStatusDiagnostic()}\ %-14.(%l,%c%V%)\ %P
endif

"---------------------------------------
" bfrg/vim-cpp-modern
"---------------------------------------
" Put all standard C and C++ keywords under Vim's highlight group 'Statement'
let g:cpp_simple_highlight = 1
"
" Disable highlighting of named requirements (C++20 library concepts)
let g:cpp_named_requirements_highlight = 0

"=======================================
" Snippet tools
"=======================================
"---------------------------------------
" SirVer/ultisnips
"---------------------------------------
" Use python version 3.x.
let g:UltiSnipsUsePythonVersion = 3
"
" Disable snipmate snippets expansion.
let g:UltiSnipsEnableSnipMate = 0
"
" Shortcut keys.
let g:UltiSnipsExpandTrigger = '<TAB>'
let g:UltiSnipsListSnippets  = '<Leader><TAB>'
let g:UltiSnipsJumpForwardTrigger  = '<TAB>'
let g:UltiSnipsJumpBackwardTrigger = '<S-TAB>'
"
" Set private directories for snippets.
" Used by :UltiSnipsEdit command.
let g:UltiSnipsSnippetsDir = vimrc_path . '/yl/UltiSnips'
"
" Set search directories for snippets.
" Used by :UltiSnipsEdit! command.
let g:UltiSnipsSnippetDirectories = [vimrc_path . '/yl/UltiSnips']

"=======================================
" Highlighting
"=======================================
"---------------------------------------
" ayuanx/vim-mark-standalone
"---------------------------------------
let g:mark_maps = 0
"
" Set hotkeys.
nmap <silent> <Leader>mm <Plug>MarkSet
xmap <silent> <Leader>mm <Plug>MarkSet
nmap <silent> <Leader>mr <Plug>MarkRegex
xmap <silent> <Leader>mr <Plug>MarkRegex
nmap <silent> <Leader>mc <Plug>MarkClear
nmap <silent> <Leader>mC <Plug>MarkAllClear
nmap <silent> <Leader>mn <Plug>MarkSearchCurrentNext
nmap <silent> <Leader>mp <Plug>MarkSearchCurrentPrev

" ======================================
" Indent guides
" ======================================
"---------------------------------------
" nathanaelkane/vim-indent-guides
"---------------------------------------
" Start automatically.
let g:indent_guides_enable_on_vim_startup = 1
"
" Disable for certain plugins.
let g:indent_guides_exclude_filetypes = [ 'help', 'nerdtree' ]
"
" Use custom colors.
let g:indent_guides_auto_colors = 0
hi IndentGuidesOdd  guibg=#262626 ctermbg=236
hi IndentGuidesEven guibg=#262626 ctermbg=236
"
" Do not change color.
" let g:indent_guides_color_change_percent = 0
"
" Show a vertical line, it is enough to identify the scopes.
let g:indent_guides_guide_size = 1
"
" Show guides from the second indent level.
let g:indent_guides_start_level = 2

"---------------------------------------
" tweekmonster/local-indent.vim
"---------------------------------------
" Enable for file types.
" autocmd FileType c,cpp,py,json  LocalIndentGuide +hl +cc
"
" Set color.
" hi LocalIndentGuide ctermfg=8 ctermbg=0 cterm=inverse

"---------------------------------------
" Yggdroot/indentLine
"---------------------------------------
" Use custom colors.
" let g:indentLine_color_term = 22
" let g:indentLine_color_gui = '#005F00'
"
" Do not change conceal options.
" let g:indentLine_setConceal = 0

"---------------------------------------
" norcalli/nvim-colorizer.lua
"---------------------------------------
" lua require 'colorizer'.setup()

"=======================================
" Colorschemes
"=======================================

"=======================================
" General tools
"=======================================
"---------------------------------------
" bronson/vim-trailing-whitespace
"---------------------------------------
" Set hotkey.
nnoremap <silent> <Leader>fw :FixWhitespace<CR>

"---------------------------------------
" derekwyatt/vim-fswitch
"---------------------------------------
" Set hotkey.
nnoremap <silent> <Leader>fs :FSHere<CR>
"
" Set destination extensions.
" *.h -> *.h, *.c, *.cpp, *.ex.c, *.ex.cpp
" Set filename alternatives.
"
" i-<fname>.h -> <fname>
autocmd BufEnter *.h  :let b:fswitchfnames = '/^//,/^i-//'
                  \|  :let b:fswitchdst = 'c,cc,cpp,cxx,ex.c,ex.cpp'
"
" Set filename alternatives.
" <fname>.c    -> <fname>
" <fname>.ex.c -> <fname>
autocmd BufEnter *.c,*.cpp  :let b:fswitchfnames = '/^//,/\.ex$//'
"
" Never create new file if the alternative file doesn't exist.
let g:fsnonewfiles = 'no'
"
" i-xxx.h  ->  xxx.h
" xxx.h    ->  i-xxx.h
function! FSwitchI()
    let l:bnr = bufnr()
    let l:fswitchdst_old    = b:fswitchdst
    let l:fswitchfnames_old = b:fswitchfnames
    let l:fswitchlocs_old   = b:fswitchlocs
    let l:ext = expand('%:e')
    let l:fn  = expand('%:t:r')
    " i-<fname>.h
    if l:ext == 'h' && match(l:fn, '^i-') != -1
        " include/i-<fname>.h  ->  src/<fname>.h
        " include/i-<fname>.h  ->  src/<fname>.cpp
        let b:fswitchdst    = 'h,cpp'
        let b:fswitchfnames = '/^i-//'
        let b:fswitchlocs   = 'reg:/include/src/'
    " <fname>.h, <fname>.cpp
    elseif l:ext == 'h' || l:ext == 'cpp'
        " src/<fname>.h    ->  include/i-<fname>.h
        " src/<fname>.cpp  ->  include/i-<fname>.h
        let b:fswitchdst    = 'h'
        let b:fswitchfnames = '/^/i-/'
        let b:fswitchlocs   = 'reg:/src/include/'
    " test-<fname>.h
    elseif l:ext == 'cpp' && match(l:fn, '^test-') != -1
        " test/test-<fname>.h  ->  **/i-<fname>.h
        let b:fswitchdst    = 'h'
        let b:fswitchfnames = '/^test-/i-/'
        let b:fswitchlocs   = 'reg:/test/**/'
    endif
    call FSwitch('%', '')
    call setbufvar(l:bnr, 'fswitchdst',    l:fswitchdst_old)
    call setbufvar(l:bnr, 'fswitchfnames', l:fswitchfnames_old)
    call setbufvar(l:bnr, 'fswitchlocs',   l:fswitchlocs_old)
endfunction
"
nnoremap <silent> <Leader>fi :call FSwitchI()<CR>
"
" i-xxx.h  ->  test-xxx.cpp
" xxx.h    ->  test-xxx.cpp
function! FSwitchT()
    let l:bnr = bufnr()
    let l:fswitchdst_old    = b:fswitchdst
    let l:fswitchfnames_old = b:fswitchfnames
    let l:fswitchlocs_old   = b:fswitchlocs
    let l:ext = expand('%:e')
    let l:fn  = expand('%:t:r')
    " i-<fname>.h
    if l:ext == 'h' && match(l:fn, '^i-') != -1
        " i-<fname>.h  ->  ../test/**/test-<fname>.h
        " i-<fname>.h  ->  ../test/**/test-<fname>.cpp
        let b:fswitchdst    = 'h,cpp'
        let b:fswitchfnames = '/^i-/test-/'
        let b:fswitchlocs   = '../test/**'
    " test-<fname>.cpp
    elseif l:ext == 'cpp' && match(l:fn, '^test-') != -1
        " /test/**/test-<fname>.cpp  ->  /**/<fname>.h
        let b:fswitchdst    = 'h,cpp'
        let b:fswitchfnames = '/^test-//'
        let b:fswitchlocs   = 'reg:/test//'
    " <fname>.h, <fname>.cpp
    elseif l:ext == 'h' || l:ext == 'c' || l:ext == 'cpp'
        " <fname>.h    ->  ../test/**/test-<fname>.cpp
        " <fname>.c    ->  ../test/**/test-<fname>.cpp
        " <fname>.cpp  ->  ../test/**/test-<fname>.cpp
        let b:fswitchdst    = 'cpp'
        let b:fswitchfnames = '/^/test-/'
        let b:fswitchlocs   = '../test/**,../../test/**'
    endif
    call FSwitch('%', '')
    call setbufvar(l:bnr, 'fswitchdst',    l:fswitchdst_old)
    call setbufvar(l:bnr, 'fswitchfnames', l:fswitchfnames_old)
    call setbufvar(l:bnr, 'fswitchlocs',   l:fswitchlocs_old)
endfunction
"
nnoremap <silent> <Leader>ft :call FSwitchT()<CR>
"
" xxx.h, xxx.cpp  <->  xxx.json, xxx.jsonc
function! FSwitchJ()
    let l:bnr = bufnr()
    if !exists('b:fswitchdst')
        call setbufvar(l:bnr, 'fswitchdst',    '')
        call setbufvar(l:bnr, 'fswitchfnames', '')
        call setbufvar(l:bnr, 'fswitchlocs',   '')
    endif
    let l:fswitchfnames_old = b:fswitchfnames
    let l:fswitchlocs_old   = b:fswitchlocs
    let l:fswitchdst_old    = b:fswitchdst
    let l:fswitchfnames_old = b:fswitchfnames
    let l:fswitchlocs_old   = b:fswitchlocs
    let l:ext = expand('%:e')
    let l:fn  = expand('%:t:r')
    " <fname>.h, <fname>.cpp
    if l:ext == 'h' || l:ext == 'c' || l:ext == 'cpp'
        " Search in current directory, or sub-directories.
        " <fname>.h    ->  **/<fname>.json
        " <fname>.c    ->  **/<fname>.json
        " <fname>.cpp  ->  **/<fname>.json
        let b:fswitchdst    = 'json,jsonc'
        let b:fswitchfnames = '/^//'
        let b:fswitchlocs   = '**'
    elseif l:ext == 'json' || l:ext == 'jsonc'
        " test-<fname>.json -> /**/<fname>.json
        let b:fswitchdst    = 'h,cpp'
        let b:fswitchfnames = '/^//'
        let b:fswitchlocs   = 'reg:/test//'
    endif
    call FSwitch('%', '')
    call setbufvar(l:bnr, 'fswitchdst',    l:fswitchdst_old)
    call setbufvar(l:bnr, 'fswitchfnames', l:fswitchfnames_old)
    call setbufvar(l:bnr, 'fswitchlocs',   l:fswitchlocs_old)
endfunction
"
nnoremap <silent> <Leader>fj :call FSwitchJ()<CR>

"---------------------------------------
" junegunn/vim-easy-align
"---------------------------------------
" Set hotkeys.
nmap <silent> ga <Plug>(EasyAlign)
xmap <silent> ga <Plug>(EasyAlign)
"
" '/': Align C++-style comment.
" 'c': Align backslash (line continuity).
let g:easy_align_delimiters = {
    \  '/': { 'pattern'        : '//\+<\{,1}',
    \         'delimiter_align': 'l',
    \         'ignore_groups'  : [] },
    \
    \  'c': { 'pattern'        : '\\',
    \         'delimiter_align': 'l',
    \         'left_margin'    : ' ' }
    \ }

"---------------------------------------
" tomtom/quickfixsigns_vim
"---------------------------------------
" Enable several classes.
let g:quickfixsigns_classes = [ 'qfl', 'marks', 'vcsdiff', 'breakpoints' ]

"---------------------------------------
" tomtom/tcomment_vim
"---------------------------------------
" Disable default maps.
let g:tcomment_maps = 0
" let g:tcomment_mapleader1 = ''
" let g:tcomment_mapleader2 = ''
" let g:tcomment_opleader1 = ''
" let g:tcomment_mapleader_uncomment_anyway = ''
" let g:tcomment_mapleader_comment_anyway = ''
"
" Toggle comment via motion.
nmap <silent> gc  <Plug>TComment_gc
xmap <silent> gc  <Plug>TComment_gc
" Toggle comment for current line.
nmap <silent> gcc <Plug>TComment_gcc

"=======================================
" IDE like
"=======================================
"---------------------------------------
" ctrlpvim/ctrlp.vim
"---------------------------------------
" let g:ctrlp_cache_dir = bundle_path . '/.cache/ctrlp'

"---------------------------------------
" mhinz/vim-startify
"---------------------------------------
let g:startify_session_dir = vimrc_path . '/session'
"
" Automatically update sessions.
let g:startify_session_persistence = 1

"---------------------------------------
" scrooloose/nerdtree
"---------------------------------------
" Set hotkey to toggle taglist window
nnoremap <silent> <Leader>tt  :NERDTreeToggle<CR>
"
" Put NERD tree at the right side of the window.
let g:NERDTreeWinPos = "right"
"
" Closes the tree window after opening a file.
let g:NERDTreeQuitOnOpen = 1
"
" Files to ignore (list of regular expressions).
let g:NERDTreeIgnore = ['\.\%(obj\|pdb\|exp\|ilk\|lib\|dll\|exe\)$']

"---------------------------------------
" vim-scripts/bufexplorer.zip
"---------------------------------------
" Enable default key mapping.
let g:bufExplorerDisableDefaultKeyMapping = 0
"
" Split new window above current.
let g:bufExplorerSplitBelow = 0
"
" Split right.
let g:bufExplorerSplitRight = 1

"---------------------------------------
" vim-scripts/mru.vim
"---------------------------------------
" Remove :MANPAGER.
" :M<Tab> expands directly to :MRU
if !has('nvim')
    autocmd VimEnter * if exists(":MANPAGER") | delcommand MANPAGER | endif
endif

"=======================================
" Tag tools
"=======================================
"---------------------------------------
" ludovicchabant/vim-gutentags
"---------------------------------------
let g:gutentags_enabled = 1
"
" Set the cache directory for tags.
let g:gutentags_cache_dir = vimrc_path . '/tags'
"
let g:gutentags_ctags_extra_args = [
    \ '-I BOOST_NOEXCEPT,BOOST_CONSTEXPR,NSFX_OVERRIDE,NSFX_FINAL'
    \ ]
"

"---------------------------------------
" majutsushi/tagbar
"---------------------------------------
" Set hotkey to toggle taglist window
" nnoremap <silent> <F11>  :TagbarToggle<CR>  Don't work in ssh mode;
nnoremap <silent> <Leader> tb :TagbarToggle<CR>
let g:tagbar_autofocus = 1
"
let g:tagbar_autoclose = 1
"
" Do not echo tag information in status line.
let g:tagbar_silent = 0
"
" Do not sort by name.
let g:tagbar_sort = 0
"
let g:tagbar_show_linenumbers = 1
"
" let g:tagbar_iconchars = ['+', '-']
"
let g:tagbar_type_cpp = {
    \ 'ctagsargs' : [
    \ '-f -',
    \ '--format=2',
    \ '--excmd=pattern',
    \ '--fields=+aimnSz',
    \ '--extra=',
    \ '--file-scope=yes',
    \ '--sort=no',
    \ '--append=no',
    \ '--c++-kinds=+p',
    \ '-I BOOST_NOEXCEPT,BOOST_CONSTEXPR,NSFX_OVERRIDE,NSFX_FINAL'
    \ ]}

"---------------------------------------
" vim-scripts/DoxygenToolkit.vim
"---------------------------------------
let g:DoxygenToolkit_paramTag_pre = '@param[in] '

"---------------------------------------
" Netrw
"---------------------------------------
" Disable Netrw.
let g:loaded_netrw       = 1
let g:loaded_netrwPlugin = 1

"===============================================================================
" Better indentation for C++ template and namespace
" @see https://github.com/benlangmuir/home/blob/master/.vim/indent/cpp.vim
"===============================================================================
function! CppIndentComment(cline_num)
    let cline_num = a:cline_num
    let pline_num = cline_num - 1
    let pline = getline(pline_num)
    "
    "     cline shall indent here
    "     |
    "     v
    " ... // ...      <= pline
    "     // ...      <= cline
    "
    " `cline` contains a C++-style comment.
    " * starts with '//'
    " * The previous line also contains a C++-style trailing comment.
    if pline =~ '\/\/'
        " Indent at the start of the comment in the previous line
        let retv = stridx(pline, '/')
    else
        let retv = cindent(cline_num)
    endif
    return retv
endfunction

function! CppIndentAsTemplate(pline_num)
    let pline_num = a:pline_num
    while 1
        let pline_num = prevnonblank(pline_num - 1)
        let pline = getline(pline_num)
        "
        " cline shall indent here
        " |
        " v
        " template<class ...,
        "          class ...,      <= pline
        "          class ...,
        "          class ...>
        " class ...                <= cline
        if pline =~# '^\s*\(class\|typename\)\>.*,\s*$'
            " Search further back until the line that declares 'template'.
            continue
        "
        " cline shall indent here
        " |
        " v
        " template<class ...,      <= pline
        "          class ...,
        "          class ...>
        " class ...                <= cline
        " elseif pline =~# '^\s*template\>'
        "     " Return the indent of the previous line that declares 'template'.
        "     let retv = cindent(pline_num)
        else
            " This line isn't a special case. Fallback to cindent.
            let retv = cindent(pline_num)
        endif
        break
    endwhile
    "
  return retv
endfunction

function! CppIndentAsTemplateOpenChevron(pline_num)
    let pline_num = a:pline_num
    while 1
        let pline_num = prevnonblank(pline_num - 1)
        let pline = getline(pline_num)
        "
        "          cline shall indent here
        "          |
        "          v
        " template<class ...,
        "          class ...,      <= pline
        "          class ...,      <= cline, OR
        "          class ...>      <= cline
        if pline =~# '^\s*\(class\|typename\)\>'
            " Search further back until the line that declares 'template'.
            continue
        "
        "          cline shall indent here
        "          |
        "          v
        " template<class ...,      <= pline
        "          class ...,      <= cline, OR
        "          class ...>      <= cline
        elseif pline =~# '^\s*template\>'
            " Return the position after the opening chevron that follows
            " 'template'.
            let retv = stridx(pline, '<') + 1
        else
            " This line isn't a special case. Fallback to cindent.
            let retv = cindent(pline_num)
        endif
        break
    endwhile
    "
  return retv
endfunction

" @pre `cline` is not a C++-style comment.
function! CppIndentNonComment(cline_num)
    let cline_num = a:cline_num
    let pline_num = prevnonblank(cline_num - 1)
    let pline = getline(pline_num)
    "
    " Skip uppercase jump labels.
    while pline ~=# '^\s*[_A-Z][_A-Z0-9]*\s*:\s*$'
        let pline_num = prevnonblank(cline_num - 1)
        let pline = getline(pline_num)
    endwhile
    "
    " cline shall indent here
    " |
    " v
    " template<class ...>      <= pline
    " class ...                <= cline
    "
    " `pline` is a single-line template declaration.
    " * starts with 'template'
    " * ends with a closing chevron '>' but not a comma ','
    if pline =~# '^\s*template\>.*>\s*$'
        " Return the indent of the previous line that declares 'template'.
        let retv = cindent(pline_num)
    "
    "          cline shall indent here
    "          |
    "          v
    " template<class ...,      <= pline, OR
    "          class ...,      <= cline, OR
    "          class ...>      <= cline
    "
    " `pline` is the first line of a multi-line template declaration.
    " * starts with 'template'
    " * ends with a comma ',' but not a closing chevron '>'
    elseif pline =~# '^\s*template\>.*,\s*$'
        " Indent at the position after the opening chevron '<'
        let retv = stridx(pline, '<') + 1
    "
    "          cline shall indent here
    "          |
    "          v
    " template<class ...,
    "          class ...,      <= pline
    "          class ...>      <= cline
    "
    " `pline` is the intermediate line of a multi-line template declaration.
    " * starts with 'class' or 'typename'
    " * ends with a comma ',' but not a closing chevron '>'
    elseif pline =~# '^\s*\(class\|typename\)\>.*,\s*$'
        " Search further back until the line that declares 'template'.
        let retv = CppIndentAsTemplateOpenChevron(pline_num)
    "
    " cline shall indent here
    " |
    " v
    " template<class ...,
    "          class ...,
    "          class ...>      <= pline
    " class ...                <= cline
    "
    " `pline` is the last line of a multi-line template declaration.
    " * starts with 'class' or 'typename'
    " * ends with a closing chevron '>' but a not comma ','
    elseif pline =~# '^\s*\(class\|typename\)\>.*>\s*$'
        " Search further back until the line that declares 'template'.
        let retv = CppIndentAsTemplate(pline_num)
    "
    " cline shall indent here
    " |
    " v
    " specifier
    " ...                      <= cline
    "
    elseif pline =~# '^\s*\(alignas\|auto\|const\|consteval\|constexpr\|constinit\|decltype\|explicit\|extern\|friend\|inline\|mutable\|register\|static\|thread_local\|using\|virtual\|volatile\)\>.*'
        let retv = cindent(pline_num)
    else
        " This line isn't a special case. Fallback to cindent.
        let retv = cindent(cline_num)
    endif
    "
  return retv
endfunction

" Correct indentation for the following declarations.
" * C++ comment
" * C++ template
" * C++ specifiers
function! CppIndent()
    let cline_num = line('.')
    let cline = getline(cline_num)
    "
    " cline shall indent here
    " |
    " v
    " LABEL:                 <= cline
    "
    " `cline` is an uppercase jump label.
    if cline =~ '^\s*[_A-Z][_A-Z0-9]*\s*:\s*$'
        let retv = 0
    "
    "     cline shall indent here
    "     |
    "     v
    " ... // ...             <= pline
    "     // ...             <= cline
    "
    " `cline` has a C++-style trailing comment.
    " * starts with '//'
    " * The above line has a C++-style trailing comment.
    elseif cline =~ '^\s*\/\/'
        let retv = CppIndentComment(cline_num)
    else
        let retv = CppIndentNonComment(cline_num)
    endif
    "
  return retv
endfunction

if has("autocmd")
    autocmd BufEnter *.{cc,cxx,cpp,h,hh,hpp,hxx} setlocal indentexpr=CppIndent()
    " '///<', '///' are repeatable start of comment.
    autocmd BufEnter *.{cc,cxx,cpp,h,hh,hpp,hxx} setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,:///<,:///,://
endif

"===============================================================================
" Coding functions
"===============================================================================
"
" Source visual selection.
xmap <Leader>vs  y:@"<CR>
"
" Source visual selection.
nnoremap <Leader>w  :noh<CR>:wall<CR>

" Delete C/C++ style comments.
" function! DeleteComments()
"     let @"=substitute(@", '^\_s*\/\*\_.\{-}\*\/\n', '', 'g')
"     let @"=substitute(@", '^\_s*\/\/.*\n', '', 'g')
" endfunction
" xnoremap <Leader>dc  y:<C-u>call DeleteComments()<CR>p
" nnoremap <Leader>dc  gvy:<C-u>call DeleteComments()<CR>p

function! AssignHotkeys()
    let __ss = ':noh<CR>'
    let __s1 = ':s/^\_s*\(\/\*\_.\{-}\*\/\\|\/\/.*\)\n//ge<CR>'
    exe 'xnoremap <Leader>dc    ' . __s1 . __ss
    exe 'nnoremap <Leader>dc  gv' . __s1 . __ss
    "
    " Replace '= 0' into 'NSFX_OVERRIDE'
    let __s1 = ':s/\s*=\s*0;/ NSFX_OVERRIDE;/ge<CR>'
    exe 'xnoremap <Leader>d0    ' . __s1 . __ss
    exe 'nnoremap <Leader>d0  gv' . __s1 . __ss
    "
    " Replace '= 0' into 'NSFX_OVERRIDE { }'
    let __s1 = ':s/\s*=\s*0;/ NSFX_OVERRIDE\r{\r}\r/ge<CR>'
    let __s2 = 'gv}='
    exe 'xnoremap <Leader>do    ' . __s1 . __s2 . __ss
    exe 'nnoremap <Leader>do  gv' . __s1 . __s2 . __ss
endfunction
call AssignHotkeys()

"===============================================================================
" Coding macros
"===============================================================================
"
"----------------------------------------
" Convert class member function declaration to definition.
" @precondition: yank class name into register 'c'
" disable highlighting search.
" :set nohls
" find '(', select lines til ')',
" 0/(     v/)V
" remove 'explicit', 'virtual', 'static', '= 0' and 'NSFX_OVERRIDE',
" :s/\s*\(explicit\|virtual\|static\|=\s*0\|NSFX_OVERRIDE\)\s*//ge
" replace two or more spaces into one space,
" :s/\s\{2,\}/ /ge
" find back '(', move before function name, paste from register 'c', add '::',
" /)?(       B                          "cP                      a::
" find back '(', select lines til ')', auto indent, move to start of line
" /)?(       v/)V                =            0
" find ')', remove ';', add '{}',
" /)      :s/;//e   o{}iA
" leave only 1 blank line by replacing 2+ blank lines that are not followed by
" 'NSFX' with 1 blank line,
" :s/\n\{2,\}\(NSFX\)\@!/\r/ge
" enable highlight search.
" :set hls
" no highlight.
" :noh
let @z=':set nohls'
    \ .'0/(v/)V'
    \ .':s/\s*\(explicit\|virtual\|static\|=\s*0\|NSFX_OVERRIDE\)\s*//ge'
    \ .':s/\s\{2,\}/ /ge'
    \ .'/)?(B"cPa::'
    \ .'/)?(v/)V=0'
    \ .'/):s/;//eo{}iA'
    \ .':s/\n\{2,\}\(NSFX\)\@!/\r/ge'
    \ .':set hls'
    \ .':noh'

"----------------------------------------
" Property definition to initialization list.
" 'size_t count_;' => 'count_(count),'
" find ';', word back, delete type til first character in line,
" 0/;     b          d^
" add comma ', ',
" i,w
" yank 'xxx_', move to end of 'xxx_',
" yw           e
" add '()', paste 'xxx_', remove '_' and ','
" a(      p             x           lx
" select line, auto indent
" V            =
" leave no blank lines by replacing 2+ blank lines with 1 blank line,
" :s/\n\{2,\}/\r/ge
" no highlighting.
" :noh
let @x='0/;bd^'
    \ .'i,w'
    \ .'ywe'
    \ .'a(pxlx'
    \ .'V='
    \ .':s/\n\{2,\}/\r/ge'
    \ .':noh'

"----------------------------------------
" Replace '= 0;' to 'NSFX_OVERRIDE;'
let @p='0/):s/\(NSFX_OVERRIDE\s\*\)\@<!= 0/NSFX_OVERRIDE/ej:noh'

"----------------------------------------
" Override a virtual function inplace.
" find '(', select lines til ')',
" 0/(     v/)V
" replace '= 0;' with 'NSFX_OVERRIDE',
" :s/\s*=\s*0\s*;/ NSFX_OVERRIDE;/e
" find back '(', select lines til ')', auto indent,
" /)?(       v/)V                =
" find ')', remove ';', add '{}',
" /)      :s/;//e   o{}ia
" leave only 1 blank line by replacing 2+ blank lines with 1 blank line
" :s/\n\{2,\}/\r/ge
" no highlighting.
" :noh
let @o='0/(v/)V'
    \ .':s/\s*=\s*0\s*;/ NSFX_OVERRIDE;/e'
    \ .'/)?(v/)V='
    \ .'/):s/;//eo{}iA'
    \ .':s/\n\{2,\}/\r/ge'
    \ .':noh'

"----------------------------------------
" Remove til '*/'.
" find '/',
" /\/
" move to the blank line before the paragraph (paragraph forward, paragraph back),
" }{
" one line down, select lines til '*/', delete
" j              v/\*\/V              d
" no highlighting.
" :noh
let @d='/\/'
    \ .'}{'
    \ .'jv/\*\/Vd'
    \ .':noh'

"----------------------------------------
" Add 'inline'.
" find '('
" /(
" move to the first column
" 0
" insert 'inline'
" iinline 
" find '{'
" /{
" find the pairing '}'
" %
" move to the blank link before the next paragraph
" }
" no highlighting
" :noh
let @h='/(0iinline /{%}:noh'

"===============================================================================
" Tags search paths.
"===============================================================================
" set tags+=../../../tag
" set tags+=../../tag
" set tags+=../tags

"===============================================================================
unlet backup_path
unlet swap_path
unlet undo_path
unlet bundle_path
unlet vimrc_path


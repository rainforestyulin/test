#include <string>
#include <fstream>
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <vector>
#include <math.h>
#include "int2char.cpp"
#include <cassert>
#include <time.h>
#include "HTTP.h"
#include "MQTT.h"
#include "flowtree.cpp"
#include "flow.h"
#include "DHCP.h"
#include "DNS.h"
#include "basic_data.h"
#include <malloc.h>
#include <pthread.h>
#include <unistd.h>
#define WIND_SIZE 2000                                  //缓冲区大小
#define ERROR_LEN 1500                                  //tcpdump异常长度界限
uint32 num=0;
uint16 flow_num=0;
uint16 current_flow=0;
uint32 current_s=0;
uint32 current_us=0;
int mqtt_v=0;
using namespace std;
unsigned char dat_wind[WIND_SIZE]={0};
string RES_PATH="./output/result.txt";                 //全局解析文件
string CUS_PATH="./output/custom.txt";                 //自定义解析文件
string V5_PATH="./output/v5file.bin";                  //v5格式文件
struct flow_list * list_head=NULL;
struct flow_head * v5_head=NULL;
unsigned int get_int(const unsigned char *addr);
unsigned int get_2bytes(const unsigned char *addr);
bool head_op(unsigned char *addr,void *file_op);
bool data_partition(unsigned char *addr,void *file_op,ifstream *red,unsigned int *read_flag);
char *get_time(char *nowtime,time_t t);
unsigned int get_int_rev(const unsigned char *addr);
void get_byte(char onebyte,char *sav_addr);
bool data_read(unsigned char* addr,unsigned int num,unsigned int *read_flag,ifstream *cap_read);
bool APP_port(unsigned char* addr,void *file_op,unsigned int  port_i,unsigned int port_o);
bool MAC_op(unsigned char *addr,void *file_of);
bool IP_analyzer(unsigned char * addr, uchar type);
bool IPv4_op(unsigned char *addr,void *file_op);
bool IPv6_op(unsigned char *addr,void *file_op);
bool TCP_op(unsigned char *addr,void * file_op);
bool UDP_op(unsigned char *addr,void * file_op);
bool ICMP_op(unsigned char *addr,void *file_op);
bool Http_op(unsigned char *addr,void *file_op);
bool DNS_op(unsigned char *addr,void *file_op);
bool DHCP_op(unsigned char *addr,void *file_op);
bool MQTT_op(unsigned char *addr,void *file_op);
bool WriteMesgInfo(ofstream *cus);
uint16 reverse_uint16(const uint16 &val);
uint32 reverse_uint32(const uint32 &val);
uint64_t reverse_uint64(const uint64_t &val);
void IP_print(ip_addr_t *ip, uchar type);
bool Flush_V5_FILE(ofstream *v5f);
void usage(char *name);
void ProtoPrint(void);
int main(int argc,char* args[]){
    assert(Init_FlowTree(0, 0, 0));
	memset(dat_wind,0,sizeof(dat_wind));
    printf("%s", notice);
    if(access("./output", 0)==-1){
    if(system("mkdir output")==-1){
        printf("ERROR:UNABLE TO CREATE OUTPUT FOLDER\n");
    }}
    char *temp;
	if(argc==1){
        printf("ERROR:NO COMMAND TRY \"NAS -h\"\n");
        return -1;
	}else{
        if(strcmp(args[1],"-v")==0){
                printf(version);
                return 0;
        }else if(strcmp(args[1], "-h")==0){
                usage(args[1]);
                return 0;
        }else if(strcmp(args[1], "-i")==0){
                ProtoPrint();
                return 0;
        }else if(strcmp(args[1], "-a")==0){
                printf("result.txt file format\n");
                printf("%s", resformat);
                return 0;
        }else if(strcmp(args[1], "-v5")==0){
                printf("v5file.bin file format:\n");
                printf("%s", v5format);
                return 0;
        }else if(strcmp(args[1], "-c")==0){
                printf("custom.txt file format:\n");
                printf("<[FlowID][CapturedTime]{Message}>\n");
                return 0;
        }else if(strcmp(args[1], "-f")==0){
                if(argc==3){
                    temp=args[2];
                }else{
                    printf("ERROR COMMAND -f, TRY \"NAS -h\"\n");
                    return 0;
                }
        }else if(strcmp(args[1], "-p")==0){
                if(argc==3){
                    char *filepath=args[2];
                    char cmd[100]="NAS_MT  ";
                    strcat(&cmd[0], filepath);
                    system(&cmd[0]);
                    printf("CALLING SUCCEED\n");
                }else{
                    printf("ERROR COMMAND -p, TRY \"NAS -h\"\n");
                }
                return 0;
        }else{
             printf("ERROR:INVALID COMMAND\n");
             return 0;
        }
    }
	unsigned int read_flag=0;
	ofstream res_write(RES_PATH);
    ofstream cus_write(CUS_PATH);
    ofstream v5_write(V5_PATH, ios::out|ios::binary);
	if(!(res_write.is_open()&&cus_write.is_open()&&v5_write.is_open())){
        cout << "ERROR:UNABLE OPEN OUTPUT FILE\n" << endl;
        return -1;
	};
    /*v5 init
     * */
    v5_head=(struct flow_head *)malloc(sizeof(struct flow_head));
    v5_head->version=5;
    v5_head->count=0;
    v5_head->SysUptime=0;
    v5_head->flow_sequence=0x12341122;                                  //非网关设备该字段空闲
    v5_head->sampling_interval=0x5678;                                  //非网关设备该字段空闲
    v5_head->unix_secs=time(NULL);
    v5_head->unix_nsecs=0;
    v5_head->engine_id=0;
    v5_write.write((char*)v5_head, sizeof(struct flow_head));

    struct FILE_OPERATOR fileP={&res_write, &cus_write, &v5_write};
	ifstream cap_read(temp);
	if (!cap_read.is_open()) {
        cout << "ERROR:UNABLE OPEN INPUT FILE\n" << endl;
        return -1;
	}
	data_read(&dat_wind[0],24,&read_flag,&cap_read);
	if(head_op(&dat_wind[0],(void*)&fileP)){}else{
        printf("ERROR:NOT PCAP FILE");
        return -1;
	};

	bool iscontinue=true;
    iscontinue=data_read(&dat_wind[24],16,&read_flag,&cap_read);
    while(iscontinue){
                data_partition(&dat_wind[24],(void*)&fileP,&cap_read,&read_flag);
                iscontinue=data_read(&dat_wind[24],16,&read_flag,&cap_read);
    };
    Flush_V5_FILE(&v5_write);
	printf("Analysis finished!\n"
                "Total fragment num is:%d, flow num is :%d\n"
            "Write finished!\n",num-1, flow_num);
	return 0;
}

/* 函数名：data_read
 * 参数：数据缓冲池地址addr，读取数量num，读取位置read_flag，文件描述符指针cap_read，
 * 功能：从指定文件的指定位置开始读取指定字节的数据到指定缓冲区
 * 返回值：成功true，失败false
 * */
bool data_read(unsigned char* addr,unsigned int num,unsigned int *read_flag,ifstream *cap_read){
	cap_read->seekg(0);
	if(cap_read->seekg(*read_flag)){
		cap_read->read((char *)addr, num);
		*read_flag=*read_flag+num;
		return true;
	}else{
		return false;
	}
}
/* 函数名：head_op
 * 参数：数据缓冲池地址addr，文件描述符指针file_op
 * 功能：从addr地址开始解析pcap文件头信息，将解析结果写入到文件中
 * 返回值：成功true，失败false
 * */
bool head_op(unsigned char *addr,void *file_op){
    struct PCAP_head *head=(struct PCAP_head *)addr;
    struct FILE_OPERATOR *filer=(struct FILE_OPERATOR *)file_op;
	int tempint2char=0;
	char tempchar[20]={0};
	filer->res->write("Data_Mode:",sizeof("Data_Mode:")-1);
	if(head->MagicNum==0xa1b2c3d4){
    filer->res->write("Big-endian\n",sizeof("Big-endian"));
	}else if(head->MagicNum==0xd4c3b2a1){
        filer->res->write("Little-endian\n",sizeof("Little-endian"));
	}else{
        printf("ERROR:FILE IS INCOMPLETE  OR NOT A PCAP FILE\n");
	    return false;
	};
	filer->res->write("File_MajorVersion:",sizeof("File_MajorVersion:")-1);
    val_deal_tool(head->MajorV,&tempchar[0],&tempint2char);
    filer->res->write(&tempchar[0], tempint2char);
	filer->res->write("\nFile_MinorVersion:",sizeof("File_MinorVersion:"));
    val_deal_tool(head->MinorV,&tempchar[0],&tempint2char);
    filer->res->write(&tempchar[0], tempint2char);
   	filer->res->write("\nMAX_store_length:",sizeof("MAX_store_length:"));
	val_deal_tool(head->SnapLen,&tempchar[0],&tempint2char);
    filer->res->write(&tempchar[0],tempint2char);
	filer->res->write("\nLink_type:",sizeof("link_type:"));
    tempint2char=0;
	while(tempint2char<=link_num){
	    assert(tempint2char<link_num);
	    if(links[tempint2char].type==*(addr+20)){
	    break;
	    }else{
	    tempint2char++;
	    }
	};
	filer->res->write(links[tempint2char].name,links[tempint2char].name_len);
	for(int i=0;i<=links[tempint2char].name_len+10;i++){
	    filer->res->write("+",1);
	}
	filer->res->write("\n",1);
	return true;
}


/* 函数名：data_partition
 * 参数：数据缓冲池地址addr，文件描述符指针file_op, 文件描述符指针red，读取位置标记read_flag，
 * 功能：从addr地址开始解析pcap帧头信息，将结果记录并读取一个帧到缓冲池，进入各层解析函数
 * 返回值：成功true，失败false
 * */
bool data_partition(unsigned char *addr,void *file_op,ifstream *red,unsigned int *read_flag){
    struct PCAP_FORMAT * block=(struct PCAP_FORMAT *)addr;
	struct FILE_OPERATOR *filer=(struct FILE_OPERATOR *)file_op;
    uint32 data_length=0;
    num++;
    data_length=get_int_rev(addr+8);
    if(data_length>ERROR_LEN){
        *read_flag=*read_flag+data_length;
        return true;
    }
	filer->res->write("\n+-----------------------------------------------+\n",sizeof("-------------------------------------------------")+1);
	int length=0;
	char tempchar[24];
    filer->res->write("\nframe_captured_time:",sizeof("frame_captured_time:"));
    current_s=get_int_rev(addr);
	filer->res->write(get_time(&tempchar[0],(time_t)current_s),19);
    current_us=get_int_rev(addr+4);
        val_deal_tool(current_us,&tempchar[0],&length);
        filer->res->write("  ",2);
        filer->res->write(&tempchar[0],length);
        filer->res->write("us\n",3);
	filer->res->write("frame_captured_length:",sizeof("frame_captured_length:")-1);
	val_deal_tool(data_length,&tempchar[0],&length);
	filer->res->write(&tempchar[0],length);
	filer->res->write("\nframe_untruncated_length:",sizeof("frame_untruncated_length:"));
	memset(tempchar,0,sizeof(tempchar));
	val_deal_tool(get_int_rev(addr+12),&tempchar[0],&length);
	filer->res->write(&tempchar[0],length);
    if(data_read(addr+16,data_length,read_flag,red)){
        MAC_op(addr+16,file_op);
	}else{
	    return false;
	}
	return true;
}

/* 函数名：MAC_op
 * 参数：数据缓冲池地址addr，文件描述符指针file_op
 * 功能：从addr地址开始解析MAC协议头部，结果写入文件，进入上一层协议解析函数
 * 返回值：成功true，失败false
 * */
bool MAC_op(unsigned char *addr,void * file_op){
    struct MAC_FORMAT *mac_head=(struct MAC_FORMAT *)addr;
    struct FILE_OPERATOR *filer=(struct FILE_OPERATOR *)file_op;
    union IP_head * ip_head=NULL;
    char tempbyte[2];
	int next_step=0;
	filer->res->write("\nTarget_MAC_address:",sizeof("Target_MAC_address:"));
	for(int i=0;i<=5;i++){
	    get_byte(mac_head->dst_mac_addr[i],&tempbyte[0]);
	    filer->res->write(&tempbyte[0],1);
	    filer->res->write(&tempbyte[1],1);
		if(i!=5){
			filer->res->write(":",1);
		}
	}
	filer->res->write("\nSource_MAC_address:",sizeof("Source_MAC_address:"));
	for(int i=0;i<=5;i++){
                get_byte(mac_head->src_mac_addr[i], &tempbyte[0]);
                filer->res->write(&tempbyte[0],1);
                filer->res->write(&tempbyte[1],1);
                if(i!=5){
                        filer->res->write(":",1);
                }
        };
	filer->res->write("\nMAC_Packet_type:",sizeof("MAC_Packet_type:"));
    uint16 &next=mac_head->type;
	for(int i=0;i<=MAC_type_num;i++){
		if(reverse_uint16(next)==MAC_types[i].type){
			next_step=MAC_types[i].type;
			filer->res->write(MAC_types[i].name,MAC_types[i].name_len);
            break;
		}else{
            if(i==MAC_type_num){
                return false;
            }
        }
	};
	switch (next_step){
		case 0x0800:
            IP_analyzer(addr+14,4);
			IPv4_op(addr+14,file_op);
            break;
		case 0x86DD:
			IPv6_op(addr+14,file_op);
            IP_analyzer(addr+14, 6);
            break;
	}
	return true;
}


/* 函数名：IP_analyzer
 * 参数：数据缓冲池地址addr, IP协议版本号
 * 功能：从addr地址开始解析IP协议头部，分析当前包所属网络流，统计并记录流信息
 * 返回值：成功true，失败false
 * */
bool IP_analyzer(unsigned char * addr, uchar type){
    FlowNode * temp=New_Node();
    FlowNode * temp1;
    uint16 srcport=0;
    uint16 dstport=0;
    uchar protocol=0;
    uint16 Plen=0;
    uchar head_len=0;
    uint32 Ptv_sec=reverse_uint32(*((uint32 *)(addr-30)));
    uint32 Ptv_usec=reverse_uint32(*((uint32 *)(addr-26)));
    switch (type) {
        case 4:
            {
                uint32 ips=*((uint32 *)(addr+12));
                uint32 ipd=*((uint32 *)(addr+16));
                temp->src_addr.ip_union._v4=ips;
                temp->dst_addr.ip_union._v4=ipd;//ip4h->dstaddr;
                head_len=((*addr)&0x0f)*4;
                Plen=*((uint16 *)(addr+2));
                protocol=*(addr+9);
                if(protocol==0x06||protocol==0x11){
                    srcport=*((uint16 *)(addr+head_len));
                    dstport=*((uint16 *)(addr+head_len+2));
                }else{
                    return false;                       //非tcp、ip报文不做记录
                }
                temp->src_port=srcport;
                temp->dst_port=dstport;
                temp->proto=protocol;//ip4h->protocol;
                temp->version=4;
                break;
            }
        case 6:
            {
                uint64_t ipsl=*((uint64_t *)(addr+8));
                uint64_t ipsh=*((uint64_t *)(addr+16));
                uint64_t ipdl=*((uint64_t *)(addr+24));
                uint64_t ipdh=*((uint64_t *)(addr+32));
                temp->src_addr.ip_union._v6[0]=ipsl;
                temp->src_addr.ip_union._v6[1]=ipsh;
                temp->dst_addr.ip_union._v6[0]=ipdl;
                temp->dst_addr.ip_union._v6[1]=ipdh;
                head_len=40;
                Plen=*((uint16 *)(addr+4));
                protocol=*(addr+6);
                if(protocol==0x06||protocol==0x11){
                    srcport=*((uint16 *)(addr+head_len));
                    dstport=*((uint16 *)(addr+head_len+2));
                }else{
                    return false;                       //非tcp、ip报文不做记录
                }
                temp->src_port=srcport;
                temp->dst_port=dstport;
                temp->proto=protocol;
                temp->version=6;
                break;
            }
        defalut:
            return false;
        };
    temp1=Lookup_Node(temp);
    if(temp1!=NULL){
        Free_Node(temp);
        current_flow=temp1->flow_id;
        uint32 Ftv_sec=temp1->t_first.tv_sec;
        uint32 Ftv_usec=temp1->t_first.tv_usec;
        uint32 Ltv_sec=temp1->t_last.tv_sec;
        uint32 Ltv_usec=temp1->t_last.tv_usec;
        if(Ptv_sec<Ftv_sec){
            temp1->t_first.tv_sec=Ptv_sec;
            temp1->t_first.tv_usec=Ptv_usec;
        }else if(Ptv_sec==Ftv_sec){
            if(Ptv_usec<Ftv_usec){
                temp1->t_first.tv_usec=Ptv_usec;
            }
        }else if(Ptv_sec>Ltv_sec){
            temp1->t_last.tv_sec=Ptv_sec;
            temp1->t_last.tv_usec=Ptv_usec;
        }else if(Ptv_sec==Ltv_sec){
            if(Ptv_usec>Ltv_usec){
                temp1->t_last.tv_usec=Ptv_usec;
            }
        };
        (temp1->packets)++;
        (temp1->bytes)+=Plen;
    }else{
        temp->packets=1;
        temp->bytes=Plen;
        temp->t_first.tv_sec=Ptv_sec;
        temp->t_first.tv_usec=Ptv_usec;
        temp->t_last.tv_sec=Ptv_sec;
        temp->t_last.tv_usec=Ptv_usec;
        temp->flow_id=flow_num;
        current_flow=temp->flow_id;
        FlowNode * tempp=Insert_Node(temp);
        flow_num++;
    };
        return true;
};


/* 函数名：IPv4_op
 * 参数：数据缓冲池地址addr, 文件描述符指针file_op
 * 功能：从addr地址开始解析IP_v4协议头部，解析结果写入文件，进入上一层解析程序
 * 返回值：成功true，失败false
 * */
bool IPv4_op(unsigned char *addr,void *file_op){
	struct IP_v4_head * ip4h=(struct IP_v4_head *)addr;
    struct FILE_OPERATOR * filer=(struct FILE_OPERATOR *)file_op;
    unsigned char TLP=0;                                // Transport Layer Protocol
	unsigned int head_len=0;
    char tempchar[20]={0};
    int tempint,j=0;
    char ver=(((*addr)&0xf0)>>4)+48;
    filer->res->write("IP_version:",sizeof("IP_version:")-1);
    filer->res->write(&ver,1);
    filer->res->write("\nIP_head_length:",sizeof("IP_head_length:"));
    head_len=((ip4h->v4b_h4b)&0x0f)*4;
    val_deal_tool(head_len,&tempchar[0],&tempint);
    filer->res->write(&tempchar[0],tempint);

	filer->res->write("\nIP_DS_flag:",sizeof("IP_DS_flag:"));
	if(ip4h->tos==0){
		filer->res->write("NULL",sizeof("NULL")-1);
	}else{
	    val_deal_tool((int)(ip4h->tos),&tempchar[0],&tempint);
		filer->res->write(&tempchar[0],tempint);
	}
	filer->res->write("\nIP_packet_length:",sizeof("IP_packet_length:"));
	val_deal_tool(reverse_uint16(ip4h->Plength),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIP_identification:",sizeof("IP_identification:"));
	val_deal_tool(reverse_uint16(ip4h->id),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIP_fragment_rule:",sizeof("IP_fragment_rule:"));
	if(((*(addr+6))&0xe0)==0x80){
		filer->res->write("fragmented->",sizeof("fragmented->")-1);
	}else if(((*(addr+6))&0xe0)==0x0){
		filer->res->write("->last-fragment",sizeof("->last-fragment")-1);
	}else if(((*(addr+6))&0xe0)==0x40){
		filer->res->write("unfragmented",sizeof("unfragmented")-1);
	}else{
		assert(0);
	};
	filer->res->write("\nIP_fragment_shift:",sizeof("IP_fragment_shift:"));
	val_u_deal_tool(((get_int(addr+6))&0x1fff)/135,&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIP_packet_TTL:",sizeof("IP_packet_TTL:"));
    val_deal_tool((get_2bytes(addr+8)&0xff00)>>8,&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIP_upper_layer_protocol:",sizeof("IP_upper_layer_protocol:"));
	for(int i=0;i<IP_num;i++){
                if(*(addr+9)==IP_types[i].type){
			            TLP=IP_types[i].type;
                        filer->res->write(IP_types[i].name,IP_types[i].name_len);
                        break;
                }else{

                }
    };

	filer->res->write("IP_source_address:",sizeof("IP_source_address:")-1);

	for(j=0;j<=3;j++){
        int newtemp=0;
		val_deal_tool((int)*(addr+12+j),&tempchar[0],&newtemp);
		filer->res->write(&tempchar[0],newtemp);
		if(j!=3){
			filer->res->write(".",1);
		}
	};
    filer->res->write("\nIP_target_address:",sizeof("IP_target_address:"));
    for(j=0;j<=3;j++){
        int newtemp=0;
        val_deal_tool((int)*(addr+16+j),&tempchar[0],&newtemp);
        filer->res->write(&tempchar[0],newtemp);
        if(j!=3){
            filer->res->write(".",1);
        }
    };
	switch (TLP){
		case 0x06:
			TCP_op(addr+(unsigned char)head_len,file_op);break;
		case 0x11:
			UDP_op(addr+(unsigned char)head_len,file_op);break;
		case 0x01:
			ICMP_op(addr+(unsigned char)head_len,file_op);break;
	};
	return true;
}


/* 函数名：IPv6_op
 * 参数：数据缓冲池地址addr, 文件描述符指针file_op
 * 功能：从addr地址开始解析IPv6协议头部，结果记录到文件，进入上一层协议解析程序
 * 返回值：成功true，失败false
 * */
bool IPv6_op(unsigned char *addr,void *file_op){
    struct FILE_OPERATOR * filer=(struct FILE_OPERATOR *)file_op;
	int next_step=0;
	int h_len=0;
	char tempchar[20]={0};
	int tempint=0;
        filer->res->write("IP_version:",sizeof("IP_version:")-1);
        char ver=(((*addr)&0xf0)>>4)+48;
        filer->res->write(&ver,1);
	filer->res->write("\nIPv6_data_level:",sizeof("IPv6_data_level:"));
	val_deal_tool((((*addr)&0x0f)<<4)+(((*(addr+1))&0xf0)>>4),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIPv6_data_flag:",sizeof("IPv6_data_flag:"));
	tempint=0;
	val_deal_tool((((*(addr+1))&0x0f)<<16)+get_2bytes(addr+2),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIPv6_carry_on:",sizeof("IPv6_carry_on:"));
	tempint=0;
        val_deal_tool(get_2bytes(addr+4),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIPv6_next_head:",sizeof("IPv6_next_head:"));
	tempint=0;
	next_step=(int)*(addr+6);
        val_deal_tool(next_step,&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIPv6_MAX_hop:",sizeof("IPv6_MAX_hop:"));
	tempint=0;
        val_deal_tool((int)*(addr+7),&tempchar[0],&tempint);
        filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nIPv6_source_address:",sizeof("IPv6_source_address:"));
	for(int i=0;i<=7;i++){
		for(int j=0;j<=1;j++){
			get_byte(*(addr+8+i*2+j),&tempchar[0]);
			filer->res->write(&tempchar[0],1);
	                filer->res->write(&tempchar[1],1);
		}
                if(i!=7){
                        filer->res->write(":",1);
                }
        };
	filer->res->write("\nIPv6_target_address:",sizeof("IPv6_target_address:"));
	for(int i=0;i<=7;i++){
                for(int j=0;j<=1;j++){
                        get_byte(*(addr+24+i*2+j),&tempchar[0]);
                        filer->res->write(&tempchar[0],1);
                        filer->res->write(&tempchar[1],1);
                }
                if(i!=7){
                        filer->res->write(":",1);
                }
        };
	switch (next_step){
                case 0x06:
                        TCP_op(addr+(unsigned char)h_len,file_op);break;
                case 0x11:
                        UDP_op(addr+(unsigned char)h_len,file_op);break;
                case 0x01:
                        ICMP_op(addr+(unsigned char)h_len,file_op);break;
        };
	return true;
}

/* 函数名：TCP_op
 * 参数：数据缓冲池地址addr, 文件描述符指针file_op
 * 功能：从addr地址开始解析TCP协议头部，结果记录到文件，进入应用层解析程序
 * 返回值：成功true，失败false
 * */
bool TCP_op(unsigned char *addr,void * file_op){
    struct FILE_OPERATOR * filer=(struct FILE_OPERATOR *)file_op;
	char tempchar[20]={0};
	int tempint=0;
	int head_len=0;
	uint16 port_i,port_o=0;
	filer->res->write("\nTCP_source_port:",sizeof("TCP_source_port:"));
	port_o=get_2bytes(addr);
	val_deal_tool(port_o,&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nTCP_target_port:",sizeof("TCP_target_port:"));
	tempint=0;
	port_i=get_2bytes(addr+2);
	val_deal_tool(port_i,&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nTCP_head_length:",sizeof("TCP_head_length:"));
	tempint=0;
	head_len=4*((((int)*(addr+12))&0xf0)>>4);
	val_deal_tool(head_len,&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	APP_port(addr+head_len,file_op,port_i,port_o);
	return true;
}


/* 函数名：UDP_op
 * 参数：数据缓冲池地址addr, 文件描述符指针file_op
 * 功能：从addr地址开始解析UDP协议头部，结果记录到文件，进入应用层解析程序
 * 返回值：成功true，失败false
 * */
bool UDP_op(unsigned char *addr,void * file_op){
    struct FILE_OPERATOR * filer=(struct FILE_OPERATOR *)file_op;
	char tempchar[20]={0};
	int tempint=0;
	int data_len=0;
	unsigned int port_i,port_o=0;
	filer->res->write("\nUDP_source_port:",sizeof("UDP_source_port:"));
	port_o=get_2bytes(addr);
	val_deal_tool(get_2bytes(addr),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nUDP_target_port:",sizeof("UDP_target_port:"));
	tempint=0;
	port_i=get_2bytes(addr+2);
	val_deal_tool(get_2bytes(addr+2),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nUDP_data_length:",sizeof("UDP_data_length:"));
	tempint=0;
	val_deal_tool(get_2bytes(addr+4),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	APP_port(addr+8,file_op,port_i,port_o);
	return true;
}

/* 函数名：ICMP_op
 * 参数：数据缓冲池地址addr, 文件描述符指针file_op
 * 功能：从addr地址开始解析ICMP协议，结果记录到文件
 * 返回值：成功true，失败false
 * */
bool ICMP_op(unsigned char *addr,void *file_op){
    struct FILE_OPERATOR * filer=(struct FILE_OPERATOR*)file_op;
	char tempchar[20]={0};
        int tempint=0;
	filer->res->write("\nICMP_type:",sizeof("ICMP_type:"));
	val_deal_tool((int)(*addr),&tempchar[0],&tempint);
	filer->res->write("\nICMP_type_code:",sizeof("ICMP_type_code:"));
	tempint=0;
	val_deal_tool((int)(*(addr+1)),&tempchar[0],&tempint);
	filer->res->write(&tempchar[0],tempint);
	filer->res->write("\nICMP_type_discription:",sizeof("ICMP_type_discription:"));
	for(int i=0;i<ICMP_num;i++){
		if((int)(*addr)==ICMP_types[i].type&&(int)(*(addr+1))==ICMP_types[i].code){
			filer->res->write(ICMP_types[i].name,ICMP_types[i].name_len);
			break;
		}
	}
	return true;
}

/* 函数名：APP_port
 * 参数：数据缓冲池地址addr, 文件描述符指针file_op,源端口号port_i, 目的端口号port_o
 * 功能：根据不同的端口号进入对应的应用层解析程序中
 * 返回值：成功true，失败false
 * */
bool APP_port(unsigned char* addr,void *file_op,unsigned int  port_i,unsigned int port_o){
        struct FILE_OPERATOR *filer=(FILE_OPERATOR *)file_op;
        if(port_i==80||port_o==80){
                filer->cus->write("<", 1);
                WriteMesgInfo(filer->cus);
                filer->cus->write("{", 1);
                Http_op(addr,file_op);
                filer->cus->write("}", 1);
                filer->cus->write(">", 1);
                filer->cus->write("\n", 1);
        }else if(port_i==53||port_o==53){
                filer->cus->write("<", 1);
                WriteMesgInfo(filer->cus);
                filer->cus->write("{", 1);
                DNS_op(addr,file_op);
                filer->cus->write("}", 1);
                filer->cus->write(">", 1);
                filer->cus->write("\n", 1);
        }else if(port_i==68||port_i==67||port_o==68||port_i==67){
                filer->cus->write("<", 1);
                WriteMesgInfo(filer->cus);
                filer->cus->write("{", 1);
                DHCP_op(addr,file_op);
                filer->cus->write("}", 1);
                filer->cus->write(">", 1);
                filer->cus->write("\n", 1);
        }else if(port_i==1883||port_o==1883){                                   //MQTT协议没有固定端口号，后续优化归至消息特征一类一并处理，暂定端口号1883
                filer->cus->write("<", 1);
                WriteMesgInfo(filer->cus);
                filer->cus->write("{", 1);
                MQTT_op(addr,file_op);
                filer->cus->write("}", 1);
                filer->cus->write(">", 1);
                filer->cus->write("\n", 1);
        }
        return true;
}

/* 函数名：WriteMesgInfo
 * 参数：自定义格式文件描述符指针cus
 * 功能：将当前流信息以及解析结果按自定义格式写入文件中
 * 返回值：成功true，失败false
 * */
bool WriteMesgInfo(ofstream *cus){
    char tempchar[20]={0};
    int tempint=0;
    val_deal_tool(current_flow,&tempchar[0], &tempint);
    cus->write("[", 1);
    cus->write(&tempchar[0], tempint);
    cus->write("]", 1);
    cus->write("[", 1);
    cus->write(get_time(&tempchar[0],(time_t)current_s),19);
    cus->write(" ", 1);
    val_deal_tool(current_us, &tempchar[0], &tempint);
    cus->write(&tempchar[0], tempint);
    cus->write("]", 1);
    return true;
};

/* 函数名：Http_op
 * 参数：数据缓冲池地址addr，文件描述符指针file_op
 * 功能：进入Http协议的解析程序中
 * 返回值：成功true，失败false
 * */
bool Http_op(unsigned char *addr,void *file_op){
    struct FILE_OPERATOR *filer=(struct FILE_OPERATOR *)file_op;
	Http mhttp((char*)addr,filer->res, filer->cus);
	return true;
}
/* 函数名：DNS_op
 * 参数：数据缓冲池地址addr，文件描述符指针file_op
 * 功能：进入DNS协议的解析程序中
 * 返回值：成功true，失败false
 * */
bool DNS_op(unsigned char *addr,void *file_op){
    struct FILE_OPERATOR *filer=(FILE_OPERATOR *)file_op;
    //char *addrt=addr;
        DNS mdns(addr,filer->res, filer->cus);
        //char *addrt=addr;
        //mdns.show();
        return true;
}
/* 函数名：DHCP_op
 * 参数：数据缓冲池地址addr，文件描述符指针file_op
 * 功能：进入DHCP协议的解析程序中
 * 返回值：成功true，失败false
 * */
bool DHCP_op(unsigned char *addr,void *file_op){
    struct FILE_OPERATOR *filer=(struct FILE_OPERATOR *)file_op;
    DHCP mdhcp(addr,filer->res, filer->cus);
	mdhcp.show();
	return true;
}
/* 函数名：MQTT_op
 * 参数：数据缓冲池地址addr，文件描述符指针file_op
 * 功能：进入MQTT协议的解析程序中
 * 返回值：成功true，失败false
 * */
bool MQTT_op(unsigned char *addr,void *file_op){
    struct FILE_OPERATOR *filer=(struct FILE_OPERATOR *)file_op;
    MQTT mmqtt(addr,filer->res, filer->cus, &mqtt_v);
	return true;
}

/* 函数名：Flush_V5_FILE
 * 参数：文件描述符指针v5f
 * 功能：将所有流信息按v5网络流格式写入文件中
 * 返回值：成功true，失败false
 * */
bool Flush_V5_FILE(ofstream *v5f){
    struct flow_info *info_body=(struct flow_info *)malloc(sizeof(flow_info));
    Dispose_FlowTree(v5f);
    return true;
}
/* 函数名：get_int
 * 参数：数据缓冲池地址addr
 * 功能：将缓冲池地址开始的四个字节按小端模式转换为int类型
 * 返回值：对应的值
 * */
unsigned int get_int(unsigned char *addr){
	unsigned int val=0;
	val=val+*(addr+3);
	val=val+((*(addr+2))<<8);
	val=val+((*(addr+1))<<16);
	val=val+((*addr)<<24);
	return val;
}
/* 函数名：get_int_rev
 * 参数：数据缓冲池地址addr
 * 功能：将缓冲池地址开始的四个字节按大端模式转换为int类型
 * 返回值：对应的值
 * */
unsigned int get_int_rev(unsigned char *addr){
	unsigned int val=0;
	val=val+((*(addr+3))<<24);
	val=val+((*(addr+2))<<16);
	val=val+((*(addr+1))<<8);
	val=val+(*addr);
	return val;
}
/* 函数名：get_2byte
 * 参数：数据缓冲池地址addr
 * 功能：将缓冲池地址开始的两个字节按小端模式转换为int类型
 * 返回值：对应的值
 * */
unsigned int get_2bytes(unsigned char *addr){
	unsigned int val=0;
	val=val+*(addr+1);
	val=val+((*addr)<<8);
	return val;
}
/* 函数名：get_byte
 * 参数：char类的待转换字符，保存转换结果的地址
 * 功能：将一个字节的值以十六进制形式保存在字符串中
 * 返回值：无
 * */
void get_byte(char onebyte,char *sav_addr){
	char onepart[2]={(onebyte&0xf0)>>4,onebyte&0x0f};
	for(int i=0;i<=1;i++){
		if(onepart[i]>=0&&onepart[i]<=9){
			*(sav_addr+i)=48+onepart[i];
		}else if(onepart[i]>=0xa&&onepart[i]<=0xf){
			*(sav_addr+i)=87+onepart[i];
		}else{
			assert(-1);
		}
	}
}
/* 函数名：IP_print
 * 参数：IP类型的指针，类型
 * 功能：打印指针所指对应类型的IP地址
 * 返回值：无
 * */
void IP_print(ip_addr_t *ip, uchar type){
    if(type==4){
        printf("%x ", ip->V4);
    }else{
        printf("%x-%x ", ip->V6[0], ip->V6[1]);
    }
}
/* 函数名：Port_print
 * 参数：Port类型的指针
 * 功能：打印端口号
 * 返回值：无
 * */

void Port_print(union Port *p){
    printf("%x:%x ", p->port_byte[0], p->port_byte[1]);
}






char *get_time(char* nowtime,time_t t){
	struct tm *lt;
	lt=localtime(&t);
	memset(nowtime,0,sizeof(nowtime));
	strftime(nowtime,24,"%Y-%m-%d %H:%M:%S",lt);
	return nowtime;
}



uint16 reverse_uint16(const uint16 &val){
    uint16 rev_val=0;
    rev_val=((val&0x00ff)<<8)|(val&0xff00)>>8;
    return rev_val;
};
uint32 reverse_uint32(const uint32 &val){
    uint32 rev_val=0;
    rev_val=((val&0xff000000)>>24|(val&0x00ff0000)>>8|(val&0x0000ff00)<<8|(val&0x000000ff)<<24);
    return rev_val;
};
uint64_t reverse_uint64(const uint64_t &val){
    uint64_t rev_val=0;
    rev_val=(val&0xff00000000000000)>>56|
        (val&0x00ff000000000000)>>40|
        (val&0x0000ff0000000000)>>24|
        (val&0x000000ff00000000)>>8|
        (val&0x00000000ff000000)<<8|
        (val&0x0000000000ff0000)<<24|
        (val&0x000000000000ff00)<<40|
        (val&0x00000000000000ff)<<56;
    return rev_val;
};
void usage(char *name) {
		printf("usage %s [options] \n"
                    "\t-f <pcap_file>\tAnalyze pcap file into result.txt custom.txt & v5file.bin.\n"
                    "\t-p <pcap_file>\tAnalyze pcap file in multithreading mode.\n"
					"\t-h\t\tPrint this message.\n"
					"\t-a\t\tExplanation of result file format.\n"
					"\t-v5\t\tExplanation of V5_Netflow file format.\n"
					"\t-c\t\tExplanation of custom file format.\n"
					"\t-v\t\tPrint version and exit.\n"
                    "\t-i\t\tPrint list of supported protocols.\n"
				, name);

} 
void ProtoPrint(void){
   printf("Following protocols are currently supported:\n");
   printf("  Data link layer:\n");
   for(int i=0;i<link_num;i++){
        printf("    %s", links[i].name);
   };
    printf("  Network layer:\n");
    for(int i=0;i<MAC_type_num;i++){
        printf("    %s", MAC_types[i].name);
   };
    printf("  Transport layer:\n");
    for(int i=0;i<IP_num;i++){
        printf("    %s", IP_types[i].name);
   };
    printf("  Application layer:\n");
    for(int i=0;i<4;i++){
        printf("    %s", trans[i].name);
   };
}

